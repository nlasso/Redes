Para normalizar los datos para el análisis calculamos el valor Z del RTT de cada hop\footnote{Recordar que nos estamos refiriendo a la diferencia entre el RTT absoluto de un hop y el anterior}, que nos da una idea de cuánto se aleja cada RTT de la media, medido en desvíos standard. Para ello usamos la ecuación facilitada por el enunciado: $$ ZRTT_i = \dfrac{RTT_i-\overline{RTT}}{SRTT}$$ donde $\overline{RTT}$ es el promedio y $SRTT$ el desvío standard de la distribución de los RTTs para una ruta dada.

Esto nos permite analizar los saltos con una información estadísticamente más sólida que la diferencia absoluta medida en $ms$.

Durante la experimentación hubieron ciertas anomalías detectadas al correr los experimentos. Las mismas fueron:

\begin{itemize}
    \item Hops que no respondían. En base a este problema se generó la hipótesis de que había hops en los cuales los paquetes ICMP enviados llegaban con un \textit{Time-Exceeded} a un router que estaba configurado para no responder a estos paquetes o para filtrarlos directamente. En base a esto se configuró el método \textit{SR1()} de Scapy pa ra que dado cierto \textit{Timeout} el mismo dejara de esperar a que el router le respondiera permitiéndonos aumentar el TTL y llegar al siguiente Hop.
    \item Corridas en las cuales no se llegaba a ningún destino haciendo que el script nunca terminara incluso aumentando el TTL y el tiempo de Timeout. Con la misma Hipotesis que la anterior, realizando experimentaciones a diferentes universidades, hubieron algunas como las que se muestran a continuación, entre otras, cuyo servidor estaba configurado para no responder:
    \begin{itemize}
        \item Universidad de Tokio
        \item Melbourne University
        \item University of Mumbay
    \end{itemize}
    En este caso, lo que se realizó para constatar este comportamiento previamente fue hacer un \textit{PING()} a los destinos para corroborar si los mismos responden. De esta manera se supo si había muchos hops que no respondían, como sucedía anteriormente, entre la IP de origen y la de destino o si era efectivamente el destino.
    \item Las rutas al mismo destino cambiaban. Al correr muchas veces a la misma IP de destino, nos dimos cuenta que las rutas podían varias con lo cual no era lo suficientemente fiable el cálculo del RTT. Dado esto, cuando se detectaba que una ruta no era igual a la primer ruta obtenida, esta era descartaba y se repetía el llamado al mismo hop con el mismo TTL hasta que se obtenía una respuesta de la primer IP con dicho TTL. De esta forma se aseguró la misma ruta en todos los casos.
\end{itemize}

